# Custom response types RFC

This RFC proposes to add the ability to return a `Response` object from procedures. This is useful when you need full control over the response, such as returning files, streams, or custom headers.

This has been a long-requested feature in [#1937](https://github.com/trpc/trpc/issues/1937) which has been partially solved already by allowing the use of handling e.g. `FormData` in mutation inputs.

## tl;dr

```ts
// Backend:
const appRouter = router({
  hello: publicProcedure.query(async () => {
    return new Response('Hello World');
  }),
});

export type AppRouter = typeof appRouter;

// Usage:
const client = createTRPCClient<AppRouter>({
  links: [
    httpLink({
      url: '/api',
    }),
  ],
});

const res = await client.hello.query();
//     ^? Response
```

## Considerations

- The responses can not be batched and will be rejected by the server if attempted (needs to be called with `httpLink()`)
- The user is responsible for properly formatting the response
- The user is responsible for setting appropriate headers
- The user is responsible for doing manual deserialization on the client
- The user is responsible for type safety on the client when needed

## Fuller example

### Different content types

```ts twoslash
import { initTRPC } from '@trpc/server';

export const t = initTRPC.create();
const publicProcedure = t.procedure;
export const appRouter = t.router({
  // Simple file download example
  downloadFile: publicProcedure.query(() => {
    return new Response('Hello World', {
      headers: {
        'Content-Type': 'text/plain',
        'Content-Disposition': 'attachment; filename="hello.txt"',
      },
    });
  }),

  // JSON stream example
  streamData: publicProcedure
    .input(z.object({ count: z.number().min(1) }))
    .mutation(async (opts) => {
      const stream = new ReadableStream({
        async start(controller) {
          const encoder = new TextEncoder();
          const data = Array.from({ length: opts.input.count }, (_, i) => ({
            value: i,
          }));

          controller.enqueue(encoder.encode(JSON.stringify(data)));
          controller.close();
        },
      });

      return new Response(stream, {
        headers: {
          'Content-Type': 'application/jsonl',
          'Cache-Control': 'no-cache',
        },
      });
    }),

  // Binary file example
  getImage: publicProcedure
    .input(z.object({ id: z.string() }))
    .query(async (opts) => {
      const imageBuffer = await getImageFromDatabase(opts.input.id); // hypothetical function

      return new Response(imageBuffer, {
        headers: {
          'Content-Type': 'image/jpeg',
          'Cache-Control': 'public, max-age=3600',
        },
      });
    }),

  // File upload and transform example
  uploadAndTransform: publicProcedure
    .input(
      zfd.formData({
        file: zfd.file(),
      }),
    )
    .mutation(async (opts) => {
      const arrayBuffer = await opts.input.file.arrayBuffer();
      const transformedBuffer = await transformImage(
        arrayBuffer,
        opts.input.format,
      ); // hypothetical function

      return new Response(transformedBuffer, {
        headers: {
          'Content-Type': `image/${opts.input.format}`,
          'Content-Disposition': `attachment; filename="transformed.${opts.input.format}"`,
          'Cache-Control': 'no-cache',
        },
      });
    }),
});
```

### Client setup

You will need to use the `httpLink`:

```ts
const client = createTRPCClient<AppRouter>({
  links: [
    splitLink({
      condition(op) {
        return Boolean(op.context.skipBatch);
      },
      true: httpLink({
        url,
      }),
      false: unstable_httpBatchStreamLink({
        url: '/api',
      }),
    }),
  ],
});

// Usage
const res = await client.downloadFile.query(undefined, {
  context: {
    skipBatch: true,
  },
});
console.log(res);
//           ^? Response
```
